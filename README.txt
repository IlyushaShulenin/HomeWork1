КУЧА - стуктура данных, представляющее собой дерево удовлетворяющее условиям:
  1) значение потомков меньше значения родителей; 
  2) поддервья каждого элемента по высоте отличаются не более чем на один кровень.

Опускание элемента(shift_up) используется при добавлении нового элемента в кучу.
Алгоритм добавления:
  1) Новый элемента ставится на самую правую свободную позицию, если на уровне есть свободное место,
иначе - создается новый уровень;
  2) Если новый элемент является больше своего родителя, то они меняются местами. Действие происходит до тех, пока
родительский элемент будет не меньше нового элемента; либо пока вставляемый элемент не станет корневым.

Поднятие элемента(shift_down) применятся при удалении элемента из кучи.
Алгоритм удаления:   
  1) Самый правый ЛИСТ становится на место удалённого корня;
  2) Элемент меняется местами с потомком с наибольшим значением до тех пор, пока не станет листом,
либо пока его потомки не будут иметь меньший приоритет.






ОЧЕРЕДЬ С ПРИОРИТЕТОМ(ОсП) - очередь, в которой элементы упорядочены по неубыванию их приоритета.
ОсП реализована на основе частично упорядоченного бинарного дерева(кучи), представленной в виде массива,
где для каждого i-го элемента его потомками являются элементы на позициях (2*i) и (2*i+1)

	3
      /   \	
     5     9		в данном примере чем меньше значение, тем выше приоритет
    / \   / 
   6   8 10
	
Массив:  { 3, 5, 9, 6, 8, 10 }

Операции с ОсП:
  * вставка(push);
  * удаление(pop);
  * получение элемента(top);
  * очистка(clear);
  * печать в виде массива(printAsArray);
  * печать в виде дерева(перевёрнутого на бок)(printAsTree).





АЛГОРИТМ ПРИМА 
Пусть множество S(addedVetices) - множество вершин, вошедших в остов; edges - множество рёбер, составляющих остов. Изначально S = 0.
Каждая вершина имеет свою метку(mark), изначально: mark(v[0]) = 0, ..., mark(v[i]) = inf, ... 
Добавим произвольную вершину в S(вершину v[0]): S = { v[0] },   edges[v[0]] = { (-1, 0) } 
Найдём ближайшую к v[0] вершину(v[i]) и добавим её в S: S = { v[0], v[i] }
Обновление пометок: если v[i] не содержится в S и вес v[0, j] меньше метки v[i], то mark(v[i]) = dist(v[0], v[i]); edges[i] = v[i]
Переходим к вершине v[i] и тд.
В итоге получаем множество рёбер минимального остова(edges).

При реализации не смог использовать кучу(((

Ответ: |edges| = 15.


  





















